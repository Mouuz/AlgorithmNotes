# DFS

1.数据结构

​	栈（函数栈，由系统提供，也可以改写成循环迭代版本手动压栈出栈）

2.空间复杂度

​	O(h) (h 为树的高度)

3.时间复杂度

​	完全二叉树 O(N）N：结点总数      邻接表图（V+E） V:顶点数  E：边数

### 不同于BFS的特性

​	不具有找到最短路特性

思路：

1. 从当前点出发，同时将当前点标记为已访问。
2. 依次遍历该结点的每一个相邻点，如果邻居节点未被访问，则递归遍历该邻居节点并将其标记为已访问。如果邻居节点已经被访问，则返回到当前节点。
3. 遍历完该节点的所有邻居节点后，返回上一个节点，继续遍历上一层节点未访问的邻居节点，若无则继续向上一个节点返回。（回溯）
4. 当所有节点都被访问过，遍历结束



例题：全排列 

```C++
#include<iostream>

using namespace std;

const int N = 10;
int path[N], n;
bool check[N];
void dfs(int u)
{
    if(u == n)
    {
        for(int i = 0; i < n; ++i)
            printf("%d ", path[i]);
        printf("\n");
        return;
    }
    
    for(int i = 1; i <= n; ++i)
    {
        if(!check[i])
        {
            path[u] = i;        //修改状态
            check[i] = true;	//
            
            dfs(u + 1);			//进入下一层	
            
            path[u] = 0;		//回溯并恢复现场，这是dfs时要特别注意的地方
            check[i] = false;	//
        }
    }
    
    
}

int main()
{
    scanf("%d",&n);
    dfs(0);
    return 0;
}
```



## 剪枝

1.可行性剪枝

​	在dfs过程中做判断，当当前路线一定不可行或者与约束条生冲突时直接返回到上一层，也就是剪枝。

2.最优性剪枝

​	在搜索过程中，如果已经找到了一个局部最优解，那么就可以停止继续搜索，或者判断哪些状态已经不可能得到更优	  	解，进行剪枝。

3.重复状态剪枝

​	在搜索过程中，记录已访问过的状态，避免重复搜索同一状态，或者发现当前状态与已知状态相同，就可以剪枝。

4.搜索深度剪枝

​	在搜索过程中，如果已搜索到一定深度后，发现这个分支已经不能再得到最优解，那么可以剪枝，不再进行搜索。这种	剪枝方式适用于深度不太深的情况。