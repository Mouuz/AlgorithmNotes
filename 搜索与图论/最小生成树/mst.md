

<img src=".\MST.png" style="zoom:57%;" />

### MST概念：

​	最小生成树是指一个含有 n 个顶点的联通加权无向图的生成树中，边的权值之和最小的生成树。简单来说，MST 问题就是在一个连通无向图中**选择一个子图**，其为一颗树**（即不含有环）**，使得这棵树中的边的权重**之和最小**。



## 朴素Prim  应用于稠密图   可以处理负权和负环

思路：

1. 创建集合U，将起点放入集合U中。
2. 寻找不在集合中，但和集合中任意点联通的点，从这些点中选择权值最小的点 v, 将 v 和其权值 w 放入集合 U中。
3. 重复步骤2直到图中的所有点都被加入到集合 U 中。
4. 最后集合 U 就是该图的最小生成树的边集。

复杂度：

​	O(n²)

模板：

```c++
//函数返回最小生成树的边权之和

int dist[N];  //dist[x] 表示顶点x距离整个集合最短的边权值
int status[N]; //用来标记那些顶点已经加入了集合当中
int g[N][N];  //稠密图用邻接矩阵存储
const int INF = 0x3f3f3f3f;	//定义正无穷

int Prim()
{
    memset(dist, 0x3f, sizeof dist);  //初始化每个顶点距离集合的距离为正无穷
   	int res = 0;  //保存权值相加之和
    //这里要做n次循环 每次往集合中加入一个确定好了的顶点，因为是最小生成树需要包含所有顶点，所以要循环n次。而dijkstra只需n-1次即可
    for(int i = 0; i < n; i++) 
    {
        int t = - 1;
        for(int j = 1; j <= n; ++j)
            //找出不在集合中，且距离集合边权值最小的顶点编号
            if(!status[j] && (t == -1 || dist[t] > dist[j])) 
                t = j;
        
        status[t] = true; //加入集合中，进行标记
        
        //如果找出的顶点t不是首个加入集合的点，且离集合的距离为INF，则说明该点和集合不联通，则该图无MST。
        if(i && dist[t] == INF) return INF; 
        
        //如果不是第一加入集合的点，则将其边权值累加求和。这里默认dist[1] = 0,也就是第一个加入集合的顶点离集合距离为0，所以不做额外处理。这里必须先累加再更新其他顶点到集合的距离，因为可能图中存在负权自环。
        if(i) res += dist[t];
        
        //用已确定加入集合的顶点t更新所有和其联通的顶点距离，相当于更新所有未在集合中的点到集合的距离
        for(int j = 1; j <= n; ++j)
    		dist[j] = min(dist[j], g[t][j]);
    }
    
    return res;
}
```





## Kruskal 应用于稀疏图

思路：

1. 将所有边按权值大小从小到大排序
2. 依次遍历每条边，如果这条边连接的两个顶点不在同一个连通块中，则将它们合并，并将这条边加入最小生成树中；
3. 重复步骤 2 直到最小生成树中包含了 n-1 条边，其中 n 是图的顶点数。

复杂度：

​	O（m*logm)

模板：

```c++
//kruskal以边结构体存储图即可
struct Edge{
    int a, b, w;   // a->b的边权值为 w
}edges[N];

int n,m;    //n:点数  m:边数
int p[N];   //并查集  p[x]的值是 x 所在集合编号

void kruskal()
{
    //所有边按权值从小到大排序
    sort(edges, edges + N, [](Edge a, Edge b){return a.w < b.w;});  
    
    int res = 0; //记录权值和
    int cnt = 0; //记录使用了边的数量
    for(int i = 1; i <= n; i++)
    {
        //遍历每条边，获取边连接的两个顶点和权值
        int a = edges[i].a,  b = edges[i].b, w = edges[i].w;
        
        //过去点a、点b 所属集合编号
        a = find(a),  b = find(b);
        
        //a b编号不同表明不属于一个集合，说明不在一个联通块中
        if(a != b)
        {
            p[a] = b;  //合并两个联通块
            cnt++; //每连上一个顶点，则已使用边数+1
            res += w; //累加权值
        }
    }
    
    //n个点的图生成的MST理应有 n-1 条边，若没有则说明有不联通的点，无MST
    if(cnt != n - 1) cout << "impossible" << endl;
    else cout << res;
}
```

