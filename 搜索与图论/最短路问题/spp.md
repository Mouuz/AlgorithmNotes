

<img src="D:\ac-win\搜索与图论\最短路问题\最短路问题.png" alt="最短路问题"/>

## 朴素Dijkstra算法

​	思路：

1. 定义一个最短距离数组`dist`，用于记录从起点到每个顶点的距离，初值为无穷大。
2. 选择一个起点，将起点的距离设为0，加入已访问集合。
3. 对于起点可直接到达的所有顶点，更新它们的距离，如果新的距离比原来的距离更小，则更新`dist[v]`的值。
4. 在所有未访问的顶点中，找到距离起点距离最小的顶点，加入已访问集合。
5. 重复步骤3和步骤4，直到所有顶点都被访问过。

### 模板:

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=510;
int n,m;
int g[N][N];//g[ 1 ][ 2 ]是指从1节点指向2节点的距离，特大值可以表示不存在
int dist[N];//distance（距离）的缩写，代表每一个点到源点的距离
bool st[N];//state(状态)的缩写,当st[n]为true时说明这个点到源点的距离最小值就已经确定了
int dijkstra(){
    memset(dist,0x3f,sizeof(dist));//存储每一个点到源点的距离
    dist[1]=0;//源点到自己的距离为0
    for(int i=0;i<n-1;i++){
    //其实这条语句唯一的作用就是循环n-1次（优化了）
    //所以写成for(int i=0;i<n;i++)也可以，因为如果下面的语句循环了n-1次的话，那么所有点都能得到最小值了
    //可以这么理解，每次循环都会确定一个最小值，还会再创造一个最小值（留给下一次循环去确定）
    //当循环n-1次时，情况是已经确定了n-1个点的最小值了，还创造了一个最小值(此时还有1个点等着下一次去确定)
    //那么就不需要下一次循环了，毕竟剩下的就一个点，在1个点的集合中知道有一个点是最小值，顺理成章了
    //当然你想写成for(int i=0;i<n;i++)也能AC~~小声说~~
        int t=-1;	//t就是要找的距离最近且未在st中点的下标，这里初始为-1方便后续比较无特殊意义
        for(int j=1;j<=n;j++){
            if(!st[j] && (t==-1 || dist[t]>dist[j])){
                t=j;//!st[j]指的是最近距离还没有确定的点，&& 后面就是找符合！st[j]条件的距离最小的点
                //这一个操作就是找到未确定最小值的 `点集`中的最小点,t==-1是当第一次遇到未确定~的点时能够被初始化
            }
        }
        
        //(1)
        
        for(int j=1;j<=n;j++){
        //现在找到t了，遍历一遍所有点，有一下几种情况
        //1.j点和t点之间无连接，那么g[t][j]=0x3f3f3f3f,特别大，会被pass
        //2.dist[j]<=dist[t]+g[t][j],源点到j点的距离,如果经过t后距离更长或相同了,那么不考虑
        //3.dist[j]>dist[t]+g[t][j], ... 经过t点距离更短了,那么修改dist[j]的值
            dist[j]=min(dist[j],dist[t]+g[t][j]);
        }
        st[t]=true;//当前t点已经把其余点全部遍历了一遍，此点变成确定距离为最小的点了,这条语句放在（1）处也能AC
    }
    if(dist[n]==0x3f3f3f3f){//当前点n没被修改，说明到不了点n，输出-1
        return -1;
    }else{
        return dist[n];//易证
    }
}
int main(){
    cin>>n>>m;//n存点数，m存边数
    memset(g,0x3f,sizeof(g));//将点之间的距离的每一个值设置成很大的数，此知识点之前讲过
    while(m--){
        int a,b,c;
        cin>>a>>b>>c;
        g[a][b]=min(g[a][b],c);//有效解决多条边的问题，保留最短边
    }
    cout<<dijkstra()<<endl;
    return 0;
}
```



## 堆优化Dijkstra算法

思路：
	由于朴素Dij算法中的第4部反应在代码中是：每次从头到尾遍历Dist数组来找出距离起点最近的顶点，复杂度为O(n)。该操作非常的耗时。由于只是每次取出距离最短的（权重最小）点，此时考虑小根堆来存储，即可用O(1)完成此操作。

```C++
#include
```

