## 单链表

此处链表主要通过数组模拟，也就是静态链表形式，避免了动态链表 new 来生成新的结点，主要是为了避免提交时出现TLE。

思路：

开辟两个数组和两个变量

```txt
E[i] :  表示节点i的值
NE[i]:	表示节点i的next节点的下标
idx  :	记录当前已经用到了数组的哪个位置的下标来存储新加入的链表节点
head :   指向第一个节点的下标值，初始化为-1，-1也作为链表结束标志
```

主要操作：

```c++
// 初始化
void init()
{
    head = -1;   //头指针 始终指向链表的第一个节点也就是头节点
    idx = 0;
}

// 将x插到头结点
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}

// 将x插到下标是k的点后面
void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}

// 将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```



## 双链表

思路：

同单链表基本相同，只是再额外添加一组数组记录前向元素的下标值

```
E[i] :  表示节点i的值
r[i] :	表示节点i的next指针是多少
l[i] :  表示节点i的pre指针是多少
idx  :	存储当前已经用到了数组的哪个点来存储链表节点
head :   指向第一个节点的下表值，初始化为-1，-1也作为链表结束标志
```

主要操作：

```c++
// 初始化,为了方便简洁，这里直接使用 0,1 来表示头和尾。
void init()
{//数组第0个元素表示头结点，第一个表示尾结点，初始化时，头节点的右边也就是next指向尾坐标，
    //尾结点的左边也就是pre指向头坐标
    r[0] = 1;
    l[1] = 0; 
    idx = 2;
}

// 将x插到下标是k的点后面或前面
void add(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
}

// 将下标是k的点删掉
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```

