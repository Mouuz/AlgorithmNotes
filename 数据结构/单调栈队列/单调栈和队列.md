## 单调栈

通过维护一个单调特性的栈，使其内部元素保持严格的单调性。从而在O(1)时间内输出最值。通常用来解决求数列中某个数左侧或右侧最近最小值

思路：（这里假定求默认当前元素左侧的最近最小元素）

维护一个严格单调性的栈空间，对数列每个数进行遍历入栈，入栈时考察：
1.栈不为空时，循环检查 : **若当前栈顶元素大于待考察的入栈元素，则将栈顶元素出栈，直到栈顶元素小于待考察元素时停止。**待考察元素入栈

2.栈为空，则直接入栈

```c++
//栈定义，为方便判断坐标 0 不存值
int stk[N], top = 0;

//若当前栈顶元素大于待考察的入栈元素，则将栈顶元素出栈，直到栈顶元素小于待考察元素时停止
while(top && stk[top] >= x) top--;

//若此时栈顶不为空，则说明找到了当前元素左侧最近最小值。
if(top) printf("%d ", stk[top]); 

//否则此时栈为空，说明栈内元素全部大于当前待入栈元素，无匹配元素。
else printf("-1 ");

//通过上述考察，已找到合适的入栈位置，待考察元素入栈
stk[++top] = x;
```





## 单调队列

原理和单调栈相同。通常用来解决求区间内最值问题。

思路：

解题思路（以最大值为例）：

由于我们需要求出的是滑动窗口的最大值。

- 如果当前的滑动窗口中有两个下标 **i** 和 **j** ，其中**i**在**j**的左侧**（i<j）**，并且i对应的元素不大于j对应的元素**（nums[i]≤nums[j]）**，则：

  当滑动窗口向右移动时，只要 **i** 还在窗口中，那么 **j** 一定也还在窗口中。这是由于 **i** 在 **j** 的左侧所保证的。

  #### 因此，由于 **nums[j]** 的存在，**nums[i]** 一定不会是滑动窗口中的最大值了，我们可以将**nums[i]**永久地移除。

  

- 因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组**nums**中对应的值是严格单调递减的。

  

- 当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。

  为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

  

- 由于队列中下标对应的元素是严格单调递减的，**因此此时队首下标对应的元素就是滑动窗口中的最大值。**


- 窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。


## 注意：

这里队列中存储的是原数列中的**值的下标**，而不是**直接存储数值**。这是为了方便判断队头元素**是否还在窗口中**，从而决定是否将队头弹出

```c++
int pre = 0, tail = -1;
    for(int i = 0; i < n; ++i)
    {
        if(pre <= tail && que[pre] < i - k + 1) pre++;
        while(pre <= tail && a[i] < a[que[tail]]) tail--;
        que[++tail] = i;
        if(i >= k - 1) printf("%d ", a[que[pre]]);
    }
```

