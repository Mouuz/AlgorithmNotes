# 并查集

### 基本原理

​		每个集合用一颗树表示，树根的编号就是整个集合的编号。每个节点存储它的父节点 ，**p[x]**表示**x**的父节点		  

### 主要操作

​		1.将两个集合合并

​		2.询问两个元素是否在一个集合中

对于额外操作则需额外维护相关信息，如查询某个元素所在集合的元素个数，就需额外维护每个集合树根的大小值（定义树根的大小表示整颗树的大小）

### 示例代码

题目： n个数，m次操作，2种操作
    1、M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
	2、Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中；

```C++
#include<iostream>

using namespace std;

const int N = 100010;

int p[N];

int find(int x)
{
    if(x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int m,n;
    scanf("%d%d",&n, &m);
    for(int i = 0; i < n; ++i)
    {
        p[i] = i;
    }

    while(m--)
    {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if(op[0] == 'M')
        {
            p[find(a)] = find(b);       
        }
        else{
            if(find(a) == find(b))
                printf("%s\n","Yes");
            else printf("%s\n","No");
        }
    }

    return 0;
}
```

